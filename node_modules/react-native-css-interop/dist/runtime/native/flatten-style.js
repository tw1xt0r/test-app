"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractValue = exports.flattenStyle = void 0;
const react_native_1 = require("react-native");
const conditions_1 = require("./conditions");
const stylesheet_1 = require("./stylesheet");
const shared_1 = require("../../shared");
const rem_1 = require("./rem");
const misc_1 = require("./misc");
function flattenStyle(style, interop, options = {}, flatStyle, depth = 0) {
    flatStyle ||= {};
    if (!style) {
        return flatStyle;
    }
    if (Array.isArray(style)) {
        if (depth > 1 && style.length > 1) {
            style.reverse();
        }
        for (const s of style) {
            flattenStyle(s, interop, options, flatStyle, depth + 1);
        }
        return flatStyle;
    }
    const styleMeta = misc_1.styleMetaMap.get(style) ?? {
        specificity: stylesheet_1.inlineSpecificity,
    };
    let flatStyleMeta = misc_1.styleMetaMap.get(flatStyle);
    if (!flatStyleMeta) {
        flatStyleMeta = { alreadyProcessed: true, specificity: stylesheet_1.inlineSpecificity };
        misc_1.styleMetaMap.set(flatStyle, flatStyleMeta);
    }
    flatStyleMeta.wrapInContext ||= Boolean(styleMeta.variables || styleMeta.container);
    if (styleMeta.pseudoClasses) {
        flatStyleMeta.pseudoClasses = {
            ...styleMeta.pseudoClasses,
            ...flatStyleMeta.pseudoClasses,
        };
        if (!(0, conditions_1.testPseudoClasses)(interop, styleMeta.pseudoClasses)) {
            return flatStyle;
        }
    }
    if (styleMeta.media && !styleMeta.media.every((m) => (0, conditions_1.testMediaQuery)(m))) {
        return flatStyle;
    }
    if (styleMeta.containerQuery &&
        !(0, conditions_1.testContainerQuery)(styleMeta.containerQuery, interop)) {
        return flatStyle;
    }
    if (styleMeta.animations) {
        flatStyleMeta.animations = {
            ...styleMeta.animations,
            ...flatStyleMeta.animations,
        };
    }
    if (styleMeta.transition) {
        flatStyleMeta.transition = {
            ...styleMeta.transition,
            ...flatStyleMeta.transition,
        };
    }
    if (styleMeta.container?.names) {
        flatStyleMeta.requiresLayoutWidth = true;
        flatStyleMeta.requiresLayoutHeight = true;
        for (const name of styleMeta.container.names) {
            interop.setContainer(name);
        }
    }
    if (styleMeta.requiresLayoutWidth) {
        flatStyleMeta.requiresLayoutWidth = true;
    }
    if (styleMeta.requiresLayoutHeight) {
        flatStyleMeta.requiresLayoutHeight = true;
    }
    if (styleMeta.variables) {
        for (const [key, value] of Object.entries(styleMeta.variables)) {
            if (interop.hasSetVariable(key)) {
                continue;
            }
            const getterOrValue = extractValue(value, flatStyle, flatStyleMeta, interop, options);
            interop.setVariable(key, getterOrValue);
        }
    }
    for (let [key, value] of Object.entries(style)) {
        if (value === undefined ||
            flatStyle[key] !== undefined) {
            continue;
        }
        switch (key) {
            case "transform": {
                if (typeof value === "string") {
                }
                else {
                    value = value.map((v) => {
                        if (!(0, shared_1.isRuntimeValue)(v))
                            return v;
                        const getterOrValue = extractValue(v, flatStyle, flatStyleMeta, interop, options);
                        if (typeof getterOrValue === "function") {
                            return Object.defineProperty({}, v.name, {
                                configurable: true,
                                enumerable: true,
                                get: getterOrValue,
                            });
                        }
                        else {
                            return {
                                [v.name]: getterOrValue,
                            };
                        }
                    });
                    Object.assign(flatStyle, ...value);
                }
                break;
            }
            case "textShadow": {
                extractAndDefineProperty("textShadow.width", value[0], flatStyle, flatStyleMeta, interop, options);
                extractAndDefineProperty("textShadow.height", value[1], flatStyle, flatStyleMeta, interop, options);
                break;
            }
            case "shadowOffset": {
                extractAndDefineProperty("shadowOffset.width", value[0], flatStyle, flatStyleMeta, interop, options);
                extractAndDefineProperty("shadowOffset.height", value[1], flatStyle, flatStyleMeta, interop, options);
                break;
            }
            default:
                extractAndDefineProperty(key, value, flatStyle, flatStyleMeta, interop, options);
        }
    }
    return flatStyle;
}
exports.flattenStyle = flattenStyle;
function extractAndDefineProperty(key, value, flatStyle, flatStyleMeta, effect, options = {}) {
    const getterOrValue = extractValue(value, flatStyle, flatStyleMeta, effect, options);
    if (getterOrValue === undefined)
        return;
    if (key.includes(".")) {
        const tokens = key.split(".");
        let target = flatStyle;
        for (const [index, token] of tokens.entries()) {
            if (index === tokens.length - 1) {
                if (typeof getterOrValue === "function") {
                    Object.defineProperty(target, token, {
                        configurable: true,
                        enumerable: true,
                        get: getterOrValue,
                    });
                }
                else {
                    Object.defineProperty(target, token, {
                        configurable: true,
                        enumerable: true,
                        value: getterOrValue,
                    });
                }
            }
            else {
                target[token] ??= {};
                target = target[token];
            }
        }
        return flatStyle;
    }
    else if (typeof getterOrValue === "function") {
        Object.defineProperty(flatStyle, key, {
            configurable: true,
            enumerable: true,
            get: getterOrValue,
        });
    }
    else {
        Object.defineProperty(flatStyle, key, {
            configurable: true,
            enumerable: true,
            value: getterOrValue,
        });
    }
}
function extractValue(value, flatStyle, flatStyleMeta, effect, options = {}) {
    if (!(0, shared_1.isRuntimeValue)(value)) {
        return value;
    }
    switch (value.name) {
        case "var": {
            const name = value.arguments[0];
            return () => {
                return effect.runInEffect(() => {
                    const resolvedValue = extractValue(effect.getVariable(name), flatStyle, flatStyleMeta, effect, options);
                    return typeof resolvedValue === "function"
                        ? resolvedValue()
                        : resolvedValue;
                });
            };
        }
        case "vh": {
            return round((misc_1.vh.get() / 100) * value.arguments[0]);
        }
        case "vw": {
            return round((misc_1.vw.get() / 100) * value.arguments[0]);
        }
        case "rem": {
            return round(rem_1.rem.get() * value.arguments[0]);
        }
        case "em": {
            return () => {
                const multiplier = value.arguments[0];
                if ("fontSize" in flatStyle) {
                    return round((flatStyle.fontSize || 0) * multiplier);
                }
                return;
            };
        }
        case "rnh": {
            const multiplier = value.arguments[0];
            let reference;
            if (options.ch) {
                reference = options.ch;
            }
            else if (typeof flatStyle.height === "number") {
                reference = flatStyle.height;
            }
            else {
                reference = effect.getLayout()[1];
            }
            if (reference) {
                return round(reference * multiplier);
            }
            else {
                return () => {
                    if (typeof flatStyle.height === "number") {
                        reference = flatStyle.height;
                    }
                    else {
                        reference = effect.getLayout()[1];
                    }
                    return round(reference * multiplier);
                };
            }
        }
        case "rnw": {
            const multiplier = value.arguments[0];
            let reference;
            if (options.cw) {
                reference = options.cw;
            }
            else if (typeof flatStyle.width === "number") {
                reference = flatStyle.width;
            }
            else {
                reference = effect.getLayout()[0];
            }
            if (reference) {
                return round(reference * multiplier);
            }
            else {
                return () => {
                    if (typeof flatStyle.width === "number") {
                        reference = flatStyle.width;
                    }
                    else {
                        reference = effect.getLayout()[0];
                    }
                    return round(reference * multiplier);
                };
            }
        }
        case "perspective":
        case "translateX":
        case "translateY":
        case "scaleX":
        case "scaleY":
        case "scale": {
            return createRuntimeFunction(value, flatStyle, flatStyleMeta, effect, options, {
                wrap: false,
            });
        }
        case "rotate":
        case "rotateX":
        case "rotateY":
        case "rotateZ":
        case "skewX":
        case "skewY": {
            return createRuntimeFunction(value, flatStyle, flatStyleMeta, effect, options, {
                wrap: false,
                parseFloat: false,
                zeroDefault: "0deg",
            });
        }
        case "hairlineWidth": {
            return stylesheet_1.StyleSheet.hairlineWidth;
        }
        case "platformSelect": {
            return createRuntimeFunction({
                ...value,
                arguments: [react_native_1.Platform.select(value.arguments[0])],
            }, flatStyle, flatStyleMeta, effect, options, {
                wrap: false,
            });
        }
        case "fontScaleSelect": {
            const specifics = value.arguments[0];
            const pixelRatio = react_native_1.PixelRatio.getFontScale();
            const match = specifics[pixelRatio] ?? specifics["native"] ?? specifics["default"];
            if (match === undefined)
                return;
            return createRuntimeFunction({
                ...value,
                arguments: [match],
            }, flatStyle, flatStyleMeta, effect, options, {
                wrap: false,
            });
        }
        case "pixelScaleSelect": {
            const specifics = value.arguments[0];
            const pixelRatio = react_native_1.PixelRatio.get();
            const match = specifics[pixelRatio] ?? specifics["native"] ?? specifics["default"];
            if (match === undefined)
                return;
            return createRuntimeFunction({
                ...value,
                arguments: [match],
            }, flatStyle, flatStyleMeta, effect, options, {
                wrap: false,
            });
        }
        case "platformColor": {
            return createRuntimeFunction(value, flatStyle, flatStyleMeta, effect, options, {
                wrap: false,
                joinArgs: false,
                callback: react_native_1.PlatformColor,
                spreadCallbackArgs: true,
            });
        }
        case "pixelScale": {
            return createRuntimeFunction(value, flatStyle, flatStyleMeta, effect, options, {
                wrap: false,
                callback: (value) => react_native_1.PixelRatio.get() * value,
            });
        }
        case "fontScale": {
            return createRuntimeFunction(value, flatStyle, flatStyleMeta, effect, options, {
                wrap: false,
                callback: (value) => react_native_1.PixelRatio.getFontScale() * value,
            });
        }
        case "getPixelSizeForLayoutSize": {
            return createRuntimeFunction(value, flatStyle, flatStyleMeta, effect, options, {
                wrap: false,
                callback: (value) => react_native_1.PixelRatio.getPixelSizeForLayoutSize(value),
            });
        }
        case "roundToNearestPixel": {
            return createRuntimeFunction({
                ...value,
                arguments: [react_native_1.PixelRatio.roundToNearestPixel(value.arguments[0])],
            }, flatStyle, flatStyleMeta, effect, options, {
                wrap: false,
            });
        }
        case "rgb": {
            return createRuntimeFunction(value, flatStyle, flatStyleMeta, effect, options, {
                joinArgs: false,
                callback(value) {
                    const args = value.slice(4, -1).split(",");
                    if (args.length === 4) {
                        return `rgba(${args.join(",")})`;
                    }
                    return value;
                },
            });
        }
        default: {
            return createRuntimeFunction(value, flatStyle, flatStyleMeta, effect, options);
        }
    }
}
exports.extractValue = extractValue;
function createRuntimeFunction(value, flatStyle, flatStyleMeta, effect, options, { wrap = true, parseFloat: shouldParseFloat = true, joinArgs: joinArguments = true, spreadCallbackArgs: spreadCallbackArguments = false, zeroDefault, callback, } = {}) {
    let isStatic = true;
    const args = [];
    if (value.arguments) {
        for (const argument of value.arguments) {
            const getterOrValue = extractValue(argument, flatStyle, flatStyleMeta, effect, options);
            if (typeof getterOrValue === "function") {
                isStatic = false;
            }
            args.push(getterOrValue);
        }
    }
    const valueFn = () => {
        let $args = args
            .map((a) => (typeof a === "function" ? a() : a))
            .filter((a) => a !== undefined);
        if (joinArguments) {
            $args = $args.join(", ");
            if ($args === "") {
                return;
            }
        }
        let result = wrap ? `${value.name}(${$args})` : $args;
        if (shouldParseFloat) {
            const float = Number.parseFloat(result);
            if (!Number.isNaN(float) && float.toString() === result) {
                result = float;
            }
        }
        if (zeroDefault && result === "0") {
            result = zeroDefault;
        }
        if (callback) {
            if (spreadCallbackArguments && Array.isArray(result)) {
                return callback(...result);
            }
            else {
                return callback(result);
            }
        }
        return result;
    };
    return isStatic ? valueFn() : valueFn;
}
function round(number) {
    return Math.round((number + Number.EPSILON) * 100) / 100;
}
//# sourceMappingURL=flatten-style.js.map