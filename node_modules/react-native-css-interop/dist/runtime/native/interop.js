"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultValues = exports.createInteropComputed = exports.useInteropComputed = void 0;
const react_1 = require("react");
const signals_1 = require("../signals");
const stylesheet_1 = require("./stylesheet");
const inheritance_1 = require("./inheritance");
const misc_1 = require("./misc");
const specificity_1 = require("../specificity");
const flatten_style_1 = require("./flatten-style");
const shared_1 = require("../../shared");
const react_native_reanimated_1 = require("react-native-reanimated");
const color_scheme_1 = require("./color-scheme");
function useInteropComputed(props, options) {
    const parent = (0, react_1.useContext)(inheritance_1.effectContext);
    const interopRef = (0, react_1.useRef)();
    if (!interopRef.current) {
        interopRef.current = createInteropComputed(options, props, parent);
    }
    else {
        interopRef.current.rerender(parent, props);
    }
    const interop = interopRef.current;
    (0, react_1.useEffect)(() => () => interop.cleanup(), []);
    (0, react_1.useEffect)(() => {
        if (signals_1.reactGlobal.delayedEvents.size) {
            for (const sub of signals_1.reactGlobal.delayedEvents) {
                sub();
            }
            signals_1.reactGlobal.delayedEvents.clear();
        }
    });
    return (0, react_1.useSyncExternalStore)(interop.subscribe, interop.peek, interop.peek);
}
exports.useInteropComputed = useInteropComputed;
function createInteropComputed(options, props, parent) {
    const interaction = {};
    const inlineSignals = new Map();
    const layoutSignal = (0, signals_1.createSignal)([0, 0], `${props.testID}#layout`);
    const signalsSetDuringRender = new Set();
    let containerSignal;
    let hasInlineContainers = false;
    let partialInterop = {
        props,
        parent,
        lastDependencies: [],
        sharedValues: {},
        isAnimated: false,
        currentAnimationNames: new Set(),
        shouldUpdateContext: false,
        requiresLayout: false,
        convertToPressable: false,
        signals: new Map(),
        setVariable(name, value) {
            signalsSetDuringRender.add(name);
            let signal = inlineSignals.get(name);
            if (!signal) {
                signal = (0, signals_1.createSignal)(value, name);
                interop.shouldUpdateContext = true;
                inlineSignals.set(name, signal);
            }
            else {
                signal.set(value);
            }
        },
        cleanup() {
            (0, signals_1.cleanupEffect)(interop);
        },
        getVariable(name) {
            let signal = inlineSignals.get(name);
            if (signal && signal.peek() !== undefined) {
                return signal.get();
            }
            signal = inheritance_1.globalVariables.universal.get(name);
            if (signal && signal.peek() !== undefined) {
                return signal.get();
            }
            signal = parent.signals.get(name);
            if (signal && signal.peek() !== undefined) {
                return signal.get();
            }
        },
        hasSetVariable(name) {
            return signalsSetDuringRender.has(name);
        },
        getContainer(name) {
            return parent.signals.get(name)?.get();
        },
        setContainer(name) {
            containerSignal ??= (0, signals_1.createSignal)(interop, name);
            hasInlineContainers = true;
            inlineSignals.set(name, containerSignal);
            signalsSetDuringRender.add(name);
            inlineSignals.set(shared_1.DEFAULT_CONTAINER_NAME, containerSignal);
            signalsSetDuringRender.add(shared_1.DEFAULT_CONTAINER_NAME);
        },
        getInteraction(name) {
            if (!interaction[name]) {
                interaction[name] = (0, signals_1.createSignal)(false, name);
            }
            return interaction[name];
        },
        setInteraction(name, value) {
            if (name in interaction) {
                interaction[name].set(value);
            }
            else {
                interaction[name] = (0, signals_1.createSignal)(value, name);
            }
        },
        getLayout() {
            return layoutSignal.get();
        },
        isLayoutReady() {
            return interop.getLayout()[0] !== 0;
        },
        rerender(parent, props) {
            let shouldRerender = parent !== interop.parent ||
                options.dependencies.some((k, i) => props[k] !== interop.lastDependencies[i]);
            if (shouldRerender) {
                interop.props = props;
                interop.parent = parent;
                interop();
            }
        },
        fn() {
            const props = interop.props;
            signals_1.reactGlobal.delayedEvents.delete(interop);
            interop.lastDependencies = options.dependencies.map((k) => props[k]);
            interop.requiresLayout = false;
            interop.shouldUpdateContext = false;
            interop.convertToPressable = false;
            signalsSetDuringRender.clear();
            hasInlineContainers = false;
            stylesheet_1.fastReloadSignal.get();
            const styledProps = {};
            let hasActive = false;
            let hasHover = false;
            let hasFocus = false;
            interop.requiresLayout = false;
            let dynamicStyles = false;
            for (const [key, { sources, nativeStyleToProp }] of options.config) {
                dynamicStyles ||= Boolean(nativeStyleToProp);
                let prop = props[key];
                let stylesToFlatten = [];
                if (prop) {
                    if (Array.isArray(prop)) {
                        prop = prop.flat(10);
                        for (const style of prop) {
                            if (!style)
                                continue;
                            dynamicStyles ||= misc_1.styleMetaMap.has(style);
                            stylesToFlatten.push((0, stylesheet_1.getGlobalStyle)(style));
                        }
                    }
                    else {
                        dynamicStyles ||= misc_1.styleMetaMap.has(prop);
                        stylesToFlatten.push((0, stylesheet_1.getGlobalStyle)(prop));
                    }
                }
                for (const sourceProp of sources) {
                    const source = props?.[sourceProp];
                    if (typeof source !== "string")
                        continue;
                    stylesheet_1.StyleSheet.unstable_hook_onClassName?.(source);
                    for (const className of source.split(/\s+/)) {
                        let styles = (0, stylesheet_1.getGlobalStyle)(className);
                        if (!styles)
                            continue;
                        if (Array.isArray(styles)) {
                            for (const style of styles) {
                                if (!style)
                                    continue;
                                dynamicStyles ||= misc_1.styleMetaMap.has(style);
                                stylesToFlatten.push(style);
                            }
                        }
                        else {
                            dynamicStyles ||= misc_1.styleMetaMap.has(styles);
                            stylesToFlatten.push(styles);
                        }
                    }
                }
                stylesToFlatten = stylesToFlatten.sort((0, specificity_1.styleSpecificityCompareFn)(dynamicStyles ? "desc" : "asc"));
                if (stylesToFlatten.length === 1) {
                    stylesToFlatten = stylesToFlatten[0];
                }
                if (!stylesToFlatten)
                    continue;
                if (!dynamicStyles) {
                    styledProps[key] = stylesToFlatten;
                    continue;
                }
                let style = (0, flatten_style_1.flattenStyle)(stylesToFlatten, interop, {}, {});
                const meta = misc_1.styleMetaMap.get(style);
                style = { ...style };
                if (meta) {
                    misc_1.styleMetaMap.set(style, meta);
                }
                if (meta) {
                    if (meta.wrapInContext && !interop.contextValue) {
                        interop.shouldUpdateContext = true;
                    }
                    hasActive ||= hasInlineContainers || meta.pseudoClasses?.active;
                    hasHover ||= hasInlineContainers || meta.pseudoClasses?.hover;
                    hasFocus ||= hasInlineContainers || meta.pseudoClasses?.focus;
                    interop.requiresLayout ||= Boolean(hasInlineContainers);
                }
                if (nativeStyleToProp) {
                    for (let [key, targetProp] of Object.entries(nativeStyleToProp)) {
                        if (key in style) {
                            if (typeof targetProp === "string") {
                                styledProps[targetProp] = style[key];
                            }
                            else {
                                styledProps[key] = style[key];
                            }
                            delete style[key];
                        }
                    }
                }
                styledProps[key] = style;
                const seenAnimatedProps = new Set();
                if (key === "style" && meta?.animations) {
                    const needsLayout = Boolean((meta.requiresLayoutWidth && style.width === undefined) ||
                        (meta.requiresLayoutHeight && style.height === undefined));
                    interop.requiresLayout ||= Boolean(meta.requiresLayoutWidth || meta.requiresLayoutHeight);
                    interop.isAnimated = true;
                    if (needsLayout && !interop.isLayoutReady()) {
                        layoutSignal.get();
                    }
                    else {
                        const a = { ...defaultAnimation, ...meta.animations };
                        let names = [];
                        let shouldResetAnimations = false;
                        for (const name of a.name) {
                            if (name.type === "none") {
                                names = [];
                                interop.currentAnimationNames.clear();
                                break;
                            }
                            names.push(name.value);
                            if (!interop.currentAnimationNames.has(name.value)) {
                                shouldResetAnimations = true;
                            }
                        }
                        if (shouldResetAnimations) {
                            interop.currentAnimationNames.clear();
                            for (let index = names.length - 1; index >= 0; index--) {
                                const name = names[index % names.length];
                                interop.currentAnimationNames.add(name);
                                const keyframes = misc_1.animationMap.get(name);
                                if (!keyframes) {
                                    continue;
                                }
                                const totalDuration = timeToMS(a.duration[index % a.name.length]);
                                const delay = timeToMS(a.delay[index % a.delay.length]);
                                const iterationCount = a.iterationCount[index % a.iterationCount.length];
                                const iterations = iterationCount.type === "infinite"
                                    ? -1
                                    : iterationCount.value;
                                for (const [prop, [initialFrame, ...frames]] of Object.entries(keyframes.frames)) {
                                    if (seenAnimatedProps.has(prop))
                                        continue;
                                    seenAnimatedProps.add(prop);
                                    const initialValue = extractAnimationValue(initialFrame, prop, style, meta, interop);
                                    const sequence = frames.map((frame) => {
                                        return (0, react_native_reanimated_1.withDelay)(delay, (0, react_native_reanimated_1.withTiming)(extractAnimationValue(frame, prop, style, meta, interop), {
                                            duration: totalDuration * frame.progress,
                                            easing: react_native_reanimated_1.Easing.linear,
                                        }));
                                    });
                                    let sharedValue = interop.sharedValues[prop];
                                    if (!sharedValue) {
                                        sharedValue = (0, react_native_reanimated_1.makeMutable)(initialValue);
                                        interop.sharedValues[prop] = sharedValue;
                                    }
                                    else {
                                        sharedValue.value = initialValue;
                                    }
                                    sharedValue.value = (0, react_native_reanimated_1.withRepeat)((0, react_native_reanimated_1.withSequence)(...sequence), iterations);
                                    styledProps[key][prop] = sharedValue;
                                }
                            }
                        }
                        else {
                            for (const name of names) {
                                const keyframes = misc_1.animationMap.get(name);
                                if (!keyframes) {
                                    continue;
                                }
                                for (const prop of Object.keys(keyframes.frames)) {
                                    seenAnimatedProps.add(prop);
                                }
                            }
                        }
                    }
                }
                else {
                    interop.currentAnimationNames.clear();
                }
                if (key === "style" && meta?.transition) {
                    interop.isAnimated = true;
                    const t = { ...defaultTransition, ...meta.transition };
                    for (let index = 0; index < t.property.length; index++) {
                        const prop = t.property[index];
                        if (seenAnimatedProps.has(prop))
                            continue;
                        let value = style[prop] ?? exports.defaultValues[prop];
                        if (typeof value === "function") {
                            value = value();
                        }
                        if (value === undefined)
                            continue;
                        seenAnimatedProps.add(prop);
                        const duration = timeToMS(t.duration[index % t.duration.length]);
                        const delay = timeToMS(t.delay[index % t.delay.length]);
                        let sharedValue = interop.sharedValues[prop];
                        if (!sharedValue) {
                            sharedValue = (0, react_native_reanimated_1.makeMutable)(value);
                            interop.sharedValues[prop] = sharedValue;
                        }
                        if (value !== sharedValue.value) {
                            sharedValue.value = (0, react_native_reanimated_1.withDelay)(delay, (0, react_native_reanimated_1.withTiming)(value, { duration }));
                        }
                        styledProps[key][prop] = sharedValue;
                    }
                }
                for (const [key, value] of Object.entries(interop.sharedValues)) {
                    if (seenAnimatedProps.has(key))
                        continue;
                    (0, react_native_reanimated_1.cancelAnimation)(value);
                    value.value = styledProps[key] ?? exports.defaultValues[key];
                }
                for (const tKey of shared_1.transformKeys) {
                    if (tKey in styledProps[key]) {
                        styledProps[key].transform ??= [];
                        styledProps[key].transform.push({
                            [tKey]: styledProps[key][tKey],
                        });
                        delete styledProps[key][tKey];
                    }
                }
            }
            styledProps.onLayout = (event) => {
                props.onLayout?.(event);
                const layout = event.nativeEvent.layout;
                const [width, height] = layoutSignal.peek();
                if (layout.width !== width || layout.height !== height) {
                    layoutSignal.set([layout.width, layout.height]);
                }
            };
            if (hasActive) {
                interop.convertToPressable = true;
                styledProps.onPressIn = (event) => {
                    props.onPressIn?.(event);
                    interop.setInteraction("active", true);
                };
                styledProps.onPressOut = (event) => {
                    props.onPressOut?.(event);
                    interop.setInteraction("active", false);
                };
            }
            if (hasHover) {
                interop.convertToPressable = true;
                styledProps.onHoverIn = (event) => {
                    props.onHoverIn?.(event);
                    interop.setInteraction("hover", true);
                };
                styledProps.onHoverOut = (event) => {
                    props.onHoverIn?.(event);
                    interop.setInteraction("hover", false);
                };
            }
            if (hasFocus) {
                interop.convertToPressable = true;
                styledProps.onFocus = (event) => {
                    props.onFocus?.(event);
                    interop.setInteraction("focus", true);
                };
                styledProps.onBlur = (event) => {
                    props.onBlur?.(event);
                    interop.setInteraction("focus", false);
                };
            }
            if (interop.convertToPressable) {
                styledProps.onPress = (event) => {
                    props.onPress?.(event);
                    interop.setInteraction("active", false);
                };
            }
            interop.signals = new Map([
                ...parent.signals,
                ...inheritance_1.globalVariables.universal,
                ...inlineSignals,
            ]);
            for (const [name, signal] of inlineSignals) {
                if (!signalsSetDuringRender.has(name)) {
                    signal.set(undefined);
                    inlineSignals.delete(name);
                    interop.shouldUpdateContext = true;
                }
            }
            interop.shouldUpdateContext ||=
                inlineSignals.size !== signalsSetDuringRender.size;
            if (interop.shouldUpdateContext) {
                interop.contextValue = Object.assign({}, interop);
            }
            return { ...interop, styledProps };
        },
    };
    const interop = Object.assign((0, signals_1.createComputed)(partialInterop.fn, false, props.testID?.toString()), partialInterop);
    interop();
    return interop;
}
exports.createInteropComputed = createInteropComputed;
const defaultTransition = {
    property: [],
    duration: [
        {
            type: "seconds",
            value: 0,
        },
    ],
    delay: [
        {
            type: "seconds",
            value: 0,
        },
    ],
    timingFunction: [{ type: "linear" }],
};
const defaultAnimation = {
    direction: ["normal"],
    fillMode: ["none"],
    iterationCount: [{ type: "number", value: 1 }],
    timingFunction: [{ type: "linear" }],
    name: [],
    playState: ["running"],
    duration: [
        {
            type: "seconds",
            value: 0,
        },
    ],
    delay: [
        {
            type: "seconds",
            value: 0,
        },
    ],
};
const timeToMS = (time) => {
    return time.type === "milliseconds" ? time.value : time.value * 1000;
};
function extractAnimationValue(frame, prop, style, meta, interop) {
    let value = frame.value === "!INHERIT!"
        ? style[prop] ?? exports.defaultValues[prop]
        : frame.value === "!INITIAL!"
            ? exports.defaultValues[prop]
            : (0, flatten_style_1.extractValue)(frame.value, style, meta, interop);
    return typeof value === "function" ? value() : value;
}
exports.defaultValues = {
    backgroundColor: "transparent",
    borderBottomColor: "transparent",
    borderBottomLeftRadius: 0,
    borderBottomRightRadius: 0,
    borderBottomWidth: 0,
    borderColor: "transparent",
    borderLeftColor: "transparent",
    borderLeftWidth: 0,
    borderRadius: 0,
    borderRightColor: "transparent",
    borderRightWidth: 0,
    borderTopColor: "transparent",
    borderTopWidth: 0,
    borderWidth: 0,
    bottom: 0,
    color: () => {
        return color_scheme_1.colorScheme.get() === "dark" ? "white" : "black";
    },
    flex: 1,
    flexBasis: 1,
    flexGrow: 1,
    flexShrink: 0,
    fontSize: 14,
    fontWeight: "400",
    gap: 0,
    left: 0,
    lineHeight: 14,
    margin: 0,
    marginBottom: 0,
    marginLeft: 0,
    marginRight: 0,
    marginTop: 0,
    maxHeight: 99999,
    maxWidth: 99999,
    minHeight: 0,
    minWidth: 0,
    opacity: 1,
    padding: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    paddingRight: 0,
    paddingTop: 0,
    perspective: 1,
    right: 0,
    rotate: "0deg",
    rotateX: "0deg",
    rotateY: "0deg",
    rotateZ: "0deg",
    scale: 1,
    scaleX: 1,
    scaleY: 1,
    skewX: "0deg",
    skewY: "0deg",
    top: 0,
    translateX: 0,
    translateY: 0,
    zIndex: 0,
};
//# sourceMappingURL=interop.js.map