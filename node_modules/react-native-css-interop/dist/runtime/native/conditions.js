"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.testCondition = exports.testContainerQuery = exports.testPseudoClasses = exports.testMediaQuery = void 0;
const misc_1 = require("./misc");
const react_native_1 = require("react-native");
const color_scheme_1 = require("./color-scheme");
const rem_1 = require("./rem");
const shared_1 = require("../../shared");
function testMediaQuery(mediaQuery, conditionReference = {
    width: misc_1.vw,
    height: misc_1.vh,
}) {
    const pass = testCondition(mediaQuery.condition, conditionReference);
    return mediaQuery.qualifier === "not" ? !pass : pass;
}
exports.testMediaQuery = testMediaQuery;
function testPseudoClasses(effect, meta) {
    let fail = false;
    if (meta.active)
        fail ||= effect.getInteraction("active").get() !== true;
    if (meta.hover)
        fail ||= effect.getInteraction("hover").get() !== true;
    if (meta.focus)
        fail ||= effect.getInteraction("focus").get() !== true;
    return !fail;
}
exports.testPseudoClasses = testPseudoClasses;
function testContainerQuery(containerQuery, effect) {
    if (!containerQuery || containerQuery.length === 0) {
        return true;
    }
    return containerQuery.every((query) => {
        let container = query.name ? effect.getContainer(query.name) : null;
        if (query.name && !container)
            return false;
        if (!container)
            container = effect.getContainer(shared_1.DEFAULT_CONTAINER_NAME);
        if (!container)
            return false;
        if (query.pseudoClasses &&
            !testPseudoClasses(container, query.pseudoClasses)) {
            return false;
        }
        if (!query.condition)
            return true;
        const layout = container.getLayout();
        return testCondition(query.condition, {
            width: layout[0],
            height: layout[1],
        });
    });
}
exports.testContainerQuery = testContainerQuery;
function testCondition(condition, conditionReference) {
    if (!condition)
        return true;
    if (condition.type === "operation") {
        if (condition.operator === "and") {
            return condition.conditions.every((c) => testCondition(c, conditionReference));
        }
        else {
            return condition.conditions.some((c) => testCondition(c, conditionReference));
        }
    }
    else if (condition.type === "not") {
        return !testCondition(condition.value, conditionReference);
    }
    else if (condition.type === "style") {
        return false;
    }
    return Boolean(testFeature(condition.value, conditionReference));
}
exports.testCondition = testCondition;
function testFeature(feature, conditionReference) {
    switch (feature.type) {
        case "plain":
            return testPlainFeature(feature, conditionReference);
        case "range":
            return testRange(feature, conditionReference);
        case "boolean":
            return testBoolean(feature);
        case "interval":
            return false;
        default:
            feature;
    }
    return false;
}
function testPlainFeature(feature, ref) {
    const value = getMediaFeatureValue(feature.value);
    if (value === null) {
        return false;
    }
    switch (feature.name) {
        case "display-mode":
            return value === "native" || react_native_1.Platform.OS === value;
        case "prefers-color-scheme":
            return color_scheme_1.colorScheme.get() === value;
        case "width":
            return testComparison("equal", ref.width, value);
        case "min-width":
            return testComparison("greater-than-equal", ref.width, value);
        case "max-width":
            return testComparison("less-than-equal", ref.width, value);
        case "height":
            return testComparison("equal", ref.height, value);
        case "min-height":
            return testComparison("greater-than-equal", ref.height, value);
        case "max-height":
            return testComparison("less-than-equal", ref.height, value);
        default:
            return false;
    }
}
function getMediaFeatureValue(value) {
    if (value.type === "number") {
        return value.value;
    }
    else if (value.type === "length") {
        if (value.value.type === "value") {
            const length = value.value.value;
            switch (length.unit) {
                case "px":
                    return length.value;
                case "rem":
                    return length.value * rem_1.rem.get();
                default:
                    return null;
            }
        }
        else {
            return null;
        }
    }
    else if (value.type === "ident") {
        return value.value;
    }
    return null;
}
function testRange(feature, ref) {
    const value = getMediaFeatureValue(feature.value);
    if (value === null || typeof value !== "number") {
        return false;
    }
    switch (feature.name) {
        case "height":
            return testComparison(feature.operator, ref.height, value);
        case "width":
            return testComparison(feature.operator, ref.width, value);
        default:
            return false;
    }
}
function testComparison(comparison, ref, value) {
    if (typeof value !== "number")
        return false;
    switch (comparison) {
        case "equal":
            return unwrap(ref) === value;
        case "greater-than":
            return unwrap(ref) > value;
        case "greater-than-equal":
            return unwrap(ref) >= value;
        case "less-than":
            return unwrap(ref) < value;
        case "less-than-equal":
            return unwrap(ref) < value;
    }
}
function testBoolean(feature) {
    switch (feature.name) {
        case "prefers-reduced-motion":
            return misc_1.isReduceMotionEnabled.get();
    }
    return false;
}
function unwrap(value) {
    return value && typeof value === "object" && "get" in value
        ? value.get()
        : value;
}
//# sourceMappingURL=conditions.js.map