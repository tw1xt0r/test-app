"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useComputed = exports.createComputed = exports.cleanupEffect = exports.createSignal = exports.reactGlobal = void 0;
const react_1 = require("react");
exports.reactGlobal = {
    isInComponent: false,
    currentStore: null,
    delayedEvents: new Set(),
};
const context = [];
function createSignal(value, id) {
    const signal = {
        subscriptions: new Set(),
        get() {
            const running = context[context.length - 1];
            if (running) {
                signal.subscriptions.add(running);
                running.dependencies.add(signal);
            }
            return value;
        },
        id,
        peek() {
            return value;
        },
        set(nextValue) {
            if (typeof nextValue === "function") {
                nextValue = nextValue(value);
            }
            if (Object.is(value, nextValue))
                return;
            value = nextValue;
            if (exports.reactGlobal.isInComponent) {
                for (const sub of signal.subscriptions) {
                    exports.reactGlobal.delayedEvents.add(sub);
                }
            }
            else {
                for (const sub of Array.from(signal.subscriptions)) {
                    sub();
                }
            }
        },
        subscribe(callback) {
            signal.subscriptions.add(callback);
            return () => signal.unsubscribe(callback);
        },
        unsubscribe(callback) {
            signal.subscriptions.delete(callback);
        },
    };
    return signal;
}
exports.createSignal = createSignal;
function setup(effect) {
    cleanupEffect(effect);
    context.push(effect);
    exports.reactGlobal.delayedEvents.delete(effect);
    exports.reactGlobal.currentStore = effect;
}
function teardown(_effect) {
    context.pop();
}
function cleanupEffect(effect) {
    for (const dep of effect.dependencies) {
        if ("subscriptions" in dep) {
            dep.subscriptions.delete(effect);
        }
    }
    effect.dependencies.clear();
    exports.reactGlobal.delayedEvents.delete(effect);
}
exports.cleanupEffect = cleanupEffect;
function createComputed(fn, runOnInitialization = true, id) {
    const effect = Object.assign(function () {
        setup(effect);
        effect.set(effect.fn);
        teardown(effect);
    }, createSignal(undefined, id), {
        dependencies: new Set(),
        fn: fn,
        runInEffect(fn) {
            context.push(effect);
            let value = fn();
            context.pop();
            return value;
        },
    });
    if (runOnInitialization) {
        effect();
    }
    return effect;
}
exports.createComputed = createComputed;
function useComputed(fn, fnDependency) {
    exports.reactGlobal.isInComponent = true;
    const computedRef = (0, react_1.useRef)();
    (0, react_1.useEffect)(() => {
        if (exports.reactGlobal.delayedEvents.size) {
            for (const sub of exports.reactGlobal.delayedEvents) {
                sub();
            }
            exports.reactGlobal.delayedEvents.clear();
        }
    });
    if (computedRef.current == null) {
        computedRef.current = Object.assign(createComputed(fn), {
            fnDependency,
        });
    }
    else if (computedRef.current.fnDependency !== fnDependency) {
        computedRef.current.fn = fn;
        computedRef.current();
    }
    return (0, react_1.useSyncExternalStore)(computedRef.current.subscribe, computedRef.current.peek, computedRef.current.peek);
}
exports.useComputed = useComputed;
//# sourceMappingURL=signals.js.map