"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAnimatedComponent = exports.remapProps = exports.defaultCSSInterop = void 0;
const react_1 = require("react");
const react_native_reanimated_1 = __importStar(require("react-native-reanimated"));
const signals_1 = require("./signals");
const react_native_1 = require("react-native");
const inheritance_1 = require("./native/inheritance");
const interop_1 = require("./native/interop");
const misc_1 = require("./native/misc");
const prop_mapping_1 = require("./native/prop-mapping");
const stylesheet_1 = require("./native/stylesheet");
const render_1 = require("./render");
const defaultCSSInterop = (component, options, props, children) => {
    signals_1.reactGlobal.isInComponent = true;
    signals_1.reactGlobal.currentStore = null;
    const effect = (0, interop_1.useInteropComputed)(props, options);
    props = {
        ...props,
        ...effect.styledProps,
    };
    for (const source of options.sources) {
        delete props[source];
    }
    if (effect.convertToPressable) {
        Object.assign(props, { ___pressable: true });
        if (component === react_native_1.View) {
            component = react_native_1.Pressable;
        }
    }
    let createElementParams = [
        effect.isAnimated ? createAnimatedComponent(component) : component,
        props,
        children,
    ];
    if (effect.isAnimated) {
        const entries = Object.entries(props.style);
        props.style = (0, react_native_reanimated_1.useAnimatedStyle)(() => {
            const style = {};
            for (const [key, value] of entries) {
                if (typeof value === "object" && "value" in value) {
                    style[key] = value.value;
                }
                else if (key === "transform") {
                    style.transform = value.map((v) => {
                        const [key, value] = Object.entries(v)[0];
                        if (typeof value === "object" && "value" in value) {
                            return { [key]: value.value };
                        }
                        else {
                            return { [key]: value };
                        }
                    });
                }
                else {
                    style[key] = value;
                }
            }
            return style;
        }, [props.style]);
    }
    signals_1.reactGlobal.isInComponent = false;
    if (effect.contextValue) {
        return [
            inheritance_1.InheritanceProvider,
            {
                value: effect.contextValue,
            },
            (0, react_1.createElement)(...createElementParams),
        ];
    }
    else {
        return createElementParams;
    }
};
exports.defaultCSSInterop = defaultCSSInterop;
function remapProps(component, mapping) {
    const { config } = (0, prop_mapping_1.getNormalizeConfig)(mapping);
    let render = ({ ...props }, ref) => {
        for (const [key, { sources }] of config) {
            let rawStyles = [];
            for (const sourceProp of sources) {
                const source = props?.[sourceProp];
                if (typeof source !== "string")
                    continue;
                delete props[sourceProp];
                for (const className of source.split(/\s+/)) {
                    const style = (0, stylesheet_1.getGlobalStyle)(className);
                    if (style !== undefined) {
                        const opaqueStyle = {};
                        const copyOfStyle = { ...style };
                        misc_1.opaqueStyles.set(opaqueStyle, copyOfStyle);
                        misc_1.styleSpecificity.set(copyOfStyle, {
                            remapped: true,
                            ...(0, stylesheet_1.getSpecificity)(style),
                        });
                        misc_1.styleMetaMap.set(opaqueStyle, {});
                        rawStyles.push(opaqueStyle);
                    }
                }
            }
            if (rawStyles.length !== 0) {
                const existingStyle = props[key];
                if (Array.isArray(existingStyle)) {
                    rawStyles.push(...existingStyle);
                }
                else if (existingStyle) {
                    rawStyles.push(existingStyle);
                }
                props[key] = rawStyles.length === 1 ? rawStyles[0] : rawStyles;
            }
        }
        props.ref = ref;
        return (0, react_1.createElement)(component, props, props.children);
    };
    render_1.interopComponents.set(component, {
        type: (0, react_1.forwardRef)(render),
        check: () => true,
        createElementWithInterop(props, children) {
            return render({ ...props, children }, null);
        },
    });
    return;
}
exports.remapProps = remapProps;
const animatedCache = new WeakMap();
function createAnimatedComponent(Component) {
    if (animatedCache.has(Component)) {
        return animatedCache.get(Component);
    }
    else if (Component.displayName?.startsWith("AnimatedComponent")) {
        return Component;
    }
    if (!(typeof Component !== "function" ||
        (Component.prototype && Component.prototype.isReactComponent))) {
        throw new Error(`Looks like you're passing an animation style to a function component \`${Component.name}\`. Please wrap your function component with \`React.forwardRef()\` or use a class component instead.`);
    }
    const AnimatedComponent = react_native_reanimated_1.default.createAnimatedComponent(Component);
    animatedCache.set(Component, AnimatedComponent);
    return AnimatedComponent;
}
exports.createAnimatedComponent = createAnimatedComponent;
//# sourceMappingURL=css-interop.native.js.map