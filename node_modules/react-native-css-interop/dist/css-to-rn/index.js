"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cssToReactNativeRuntime = void 0;
const lightningcss_1 = require("lightningcss");
const shared_1 = require("../shared");
const parseDeclaration_1 = require("./parseDeclaration");
const normalize_selectors_1 = require("./normalize-selectors");
function cssToReactNativeRuntime(code, options = {}) {
    code = typeof code === "string" ? code : code.toString("utf-8");
    code = code.replaceAll("-webkit-text-size-adjust: 100%;", "");
    code = Buffer.from(code);
    const grouping = options.grouping?.map((value) => {
        return typeof value === "string" ? new RegExp(value) : value;
    }) ?? [];
    const extractOptions = {
        ...options,
        darkMode: { type: "media" },
        grouping,
        declarations: new Map(),
        keyframes: new Map(),
        rootVariables: {},
        universalVariables: {},
        flags: {},
        appearanceOrder: 0,
    };
    (0, lightningcss_1.transform)({
        filename: "style.css",
        code,
        visitor: {
            Rule(rule) {
                extractRule(rule, extractOptions);
                return [];
            },
        },
        customAtRules: {
            cssInterop: {
                prelude: "<custom-ident>+",
            },
        },
    });
    return {
        declarations: Object.fromEntries(extractOptions.declarations),
        keyframes: Object.fromEntries(extractOptions.keyframes),
        rootVariables: extractOptions.rootVariables,
        universalVariables: extractOptions.universalVariables,
        flags: extractOptions.flags,
    };
}
exports.cssToReactNativeRuntime = cssToReactNativeRuntime;
function extractRule(rule, extractOptions, partialStyle = {}) {
    switch (rule.type) {
        case "keyframes": {
            extractKeyFrames(rule.value, extractOptions);
            break;
        }
        case "container": {
            extractedContainer(rule.value, extractOptions);
            break;
        }
        case "media": {
            extractMedia(rule.value, extractOptions);
            break;
        }
        case "style": {
            if (rule.value.declarations) {
                for (const style of getExtractedStyles(rule.value.declarations, extractOptions)) {
                    setStyleForSelectorList({ ...partialStyle, ...style }, rule.value.selectors, extractOptions);
                }
                extractOptions.appearanceOrder++;
            }
            break;
        }
        case "custom": {
            if (rule.value && rule.value?.name === "cssInterop") {
                extractCSSInteropFlag(rule, extractOptions);
            }
        }
    }
}
function extractCSSInteropFlag(rule, extractOptions) {
    if (rule.value.prelude.value.components[0].value !== "set") {
        return;
    }
    const [_, name, type, ...other] = rule.value.prelude.value.components.map((c) => c.value);
    if (name === "darkMode") {
        let value;
        if (other.length === 0 || other[0] === "media") {
            extractOptions.darkMode = { type: "media" };
        }
        else {
            value = other[0];
            if (value.startsWith(".")) {
                value = value.slice(1);
                extractOptions.darkMode = { type: "class", value };
            }
            else if (value.startsWith("[")) {
                extractOptions.darkMode = { type: "attribute", value };
            }
            else if (value === "dark") {
                extractOptions.darkMode = { type: "class", value };
            }
        }
        extractOptions.flags.darkMode = `${type} ${value}`.trim();
    }
    else {
        const value = other.length === 0 ? "true" : other;
        extractOptions.flags[name] = value;
    }
}
function extractMedia(mediaRule, extractOptions) {
    const media = [];
    for (const mediaQuery of mediaRule.query.mediaQueries) {
        let isScreen = mediaQuery.mediaType !== "print";
        if (mediaQuery.qualifier === "not") {
            isScreen = !isScreen;
        }
        if (isScreen) {
            media.push(mediaQuery);
        }
    }
    if (media.length === 0) {
        return;
    }
    for (const rule of mediaRule.rules) {
        extractRule(rule, extractOptions, { media });
    }
}
function extractedContainer(containerRule, extractOptions) {
    for (const rule of containerRule.rules) {
        extractRule(rule, extractOptions, {
            containerQuery: [
                {
                    name: containerRule.name,
                    condition: containerRule.condition,
                },
            ],
        });
    }
}
function setStyleForSelectorList(extractedStyle, selectorList, options) {
    const { declarations } = options;
    for (const selector of (0, normalize_selectors_1.normalizeSelectors)(extractedStyle, selectorList, options)) {
        const style = { ...extractedStyle };
        if (selector.type === "rootVariables" ||
            selector.type === "universalVariables") {
            if (!style.variables) {
                continue;
            }
            const { type, subtype } = selector;
            const record = (options[type] ??= {});
            for (const [name, value] of Object.entries(style.variables)) {
                record[name] ??= {};
                record[name][subtype] = value;
            }
            continue;
        }
        else if (selector.type === "className") {
            const { className, groupClassName, pseudoClasses, groupPseudoClasses, darkMode, } = selector;
            const specificity = {
                ...extractedStyle.specificity,
                ...selector.specificity,
            };
            if (groupClassName) {
                addDeclaration(groupClassName, {
                    style: {},
                    specificity,
                    container: {
                        names: [groupClassName],
                    },
                }, declarations);
                style.containerQuery ??= [];
                style.containerQuery.push({
                    name: groupClassName,
                    pseudoClasses: groupPseudoClasses,
                });
            }
            if (darkMode) {
                style.media ??= [];
                style.media.push({
                    mediaType: "all",
                    condition: {
                        type: "feature",
                        value: {
                            type: "plain",
                            name: "prefers-color-scheme",
                            value: { type: "ident", value: "dark" },
                        },
                    },
                });
            }
            addDeclaration(className, { ...style, specificity, pseudoClasses }, declarations);
        }
    }
}
function addDeclaration(className, style, declarations) {
    const existing = declarations.get(className);
    if (Array.isArray(existing)) {
        existing.push(style);
    }
    else if (existing) {
        declarations.set(className, [existing, style]);
    }
    else {
        declarations.set(className, style);
    }
}
function extractKeyFrames(keyframes, extractOptions) {
    const extractedAnimation = { frames: {} };
    const frames = extractedAnimation.frames;
    let rawFrames = [];
    for (const frame of keyframes.keyframes) {
        if (!frame.declarations.declarations)
            continue;
        const { style } = declarationsToStyle(frame.declarations.declarations, {
            ...extractOptions,
            useInitialIfUndefined: true,
            requiresLayout(name) {
                if (name === "rnw") {
                    extractedAnimation.requiresLayoutWidth = true;
                }
                else {
                    extractedAnimation.requiresLayoutHeight = true;
                }
            },
        }, {
            I: 99,
            S: 1,
            O: extractOptions.appearanceOrder,
        });
        for (const selector of frame.selectors) {
            const keyframe = selector.type === "percentage"
                ? selector.value * 100
                : selector.type === "from"
                    ? 0
                    : selector.type === "to"
                        ? 100
                        : undefined;
            if (keyframe === undefined)
                continue;
            switch (selector.type) {
                case "percentage":
                    rawFrames.push({ selector: selector.value, style });
                    break;
                case "from":
                    rawFrames.push({ selector: 0, style });
                    break;
                case "to":
                    rawFrames.push({ selector: 1, style });
                    break;
                default:
                    selector;
            }
        }
    }
    rawFrames = rawFrames.sort((a, b) => a.selector - b.selector);
    for (let i = 0; i < rawFrames.length; i++) {
        const frame = rawFrames[i];
        const animationProgress = frame.selector;
        const previousProgress = i === 0 ? 0 : rawFrames[i - 1].selector;
        const progress = animationProgress - previousProgress;
        for (const [prop, value] of Object.entries(frame.style)) {
            if (progress === 0) {
                frames[prop] = [];
            }
            else {
                frames[prop] ??= [{ value: "!INHERIT!", progress: 0 }];
            }
            frames[prop].push({
                value,
                progress,
            });
        }
    }
    extractOptions.keyframes.set(keyframes.name.value, extractedAnimation);
}
function getExtractedStyles(declarationBlock, options) {
    const extractedStyles = [];
    if (declarationBlock.declarations && declarationBlock.declarations.length) {
        extractedStyles.push(declarationsToStyle(declarationBlock.declarations, options, {
            I: 0,
            S: 1,
            O: options.appearanceOrder,
        }));
    }
    if (declarationBlock.importantDeclarations &&
        declarationBlock.importantDeclarations.length) {
        extractedStyles.push(declarationsToStyle(declarationBlock.importantDeclarations, options, {
            I: 1,
            S: 1,
            O: options.appearanceOrder,
        }));
    }
    return extractedStyles;
}
function declarationsToStyle(declarations, options, specificity) {
    const extractedStyle = {
        style: {},
        specificity: { A: 0, B: 0, C: 0, ...specificity },
    };
    let processingImportant = false;
    function addStyleProp(property, value, { append = false } = {}) {
        if (value === undefined && options.useInitialIfUndefined) {
            value = "!INITIAL!";
        }
        if (value === undefined) {
            return;
        }
        if (property.startsWith("--")) {
            return addVariable(property, value);
        }
        property = kebabToCamelCase(property);
        const style = extractedStyle.style;
        if (append) {
            const styleValue = style[property];
            if (Array.isArray(styleValue)) {
                styleValue.push(...value);
            }
            else {
                style[property] = [value];
            }
        }
        else {
            style[property] = value;
        }
        if ((0, shared_1.isRuntimeValue)(value) || shared_1.transformKeys.includes(property)) {
            extractedStyle.isDynamic = true;
        }
        if (processingImportant) {
            extractedStyle.importantStyles ??= [];
            extractedStyle.importantStyles.push(property);
        }
    }
    function handleStyleShorthand(name, options) {
        if (allEqual(...Object.values(options))) {
            return addStyleProp(name, Object.values(options)[0]);
        }
        else {
            for (const [name, value] of Object.entries(options)) {
                addStyleProp(name, value);
            }
        }
    }
    function addVariable(property, value) {
        extractedStyle.variables ??= {};
        extractedStyle.variables[property] = value;
    }
    function addContainerProp(declaration) {
        let names = [shared_1.DEFAULT_CONTAINER_NAME];
        let type;
        switch (declaration.property) {
            case "container":
                if (declaration.value.name.type === "none") {
                    names = false;
                }
                else {
                    names = declaration.value.name.value;
                }
                type = declaration.value.containerType;
                break;
            case "container-name":
                if (declaration.value.type === "none") {
                    names = false;
                }
                else {
                    names = declaration.value.value;
                }
                break;
            case "container-type":
                type = declaration.value;
                break;
        }
        extractedStyle.container ??= {};
        if (names === false) {
            extractedStyle.container.names = false;
        }
        else if (Array.isArray(extractedStyle.container.names)) {
            extractedStyle.container.names = [
                ...new Set([...extractedStyle.container.names, ...names]),
            ];
        }
        else {
            extractedStyle.container.names = names;
        }
        if (type) {
            extractedStyle.container ??= {};
            extractedStyle.container.type = type;
        }
    }
    function addTransitionProp(declaration) {
        extractedStyle.transition ??= {};
        switch (declaration.property) {
            case "transition-property":
                extractedStyle.transition.property = declaration.value.map((v) => {
                    return kebabToCamelCase(v.property);
                });
                break;
            case "transition-duration":
                extractedStyle.transition.duration = declaration.value;
                break;
            case "transition-delay":
                extractedStyle.transition.delay = declaration.value;
                break;
            case "transition-timing-function":
                extractedStyle.transition.timingFunction = declaration.value;
                break;
            case "transition": {
                let setProperty = true;
                let setDuration = true;
                let setDelay = true;
                let setTiming = true;
                if (extractedStyle.transition.property) {
                    setProperty = false;
                }
                else {
                    extractedStyle.transition.property = [];
                }
                if (extractedStyle.transition.duration) {
                    setDuration = false;
                }
                else {
                    extractedStyle.transition.duration = [];
                }
                if (extractedStyle.transition.delay) {
                    setDelay = false;
                }
                else {
                    extractedStyle.transition.delay = [];
                }
                if (extractedStyle.transition.timingFunction) {
                    setTiming = false;
                }
                else {
                    extractedStyle.transition.timingFunction = [];
                }
                for (const value of declaration.value) {
                    if (setProperty) {
                        extractedStyle.transition.property?.push(kebabToCamelCase(value.property.property));
                    }
                    if (setDuration) {
                        extractedStyle.transition.duration?.push(value.duration);
                    }
                    if (setDelay) {
                        extractedStyle.transition.delay?.push(value.delay);
                    }
                    if (setTiming) {
                        extractedStyle.transition.timingFunction?.push(value.timingFunction);
                    }
                }
                break;
            }
        }
    }
    function addAnimationProp(property, value) {
        if (property === "animation") {
            const groupedProperties = {};
            for (const animation of value) {
                for (const [key, value] of Object.entries(animation)) {
                    groupedProperties[key] ??= [];
                    groupedProperties[key].push(value);
                }
            }
            extractedStyle.animations ??= {};
            for (const [property, value] of Object.entries(groupedProperties)) {
                const key = property
                    .replace("animation-", "")
                    .replace(/-./g, (x) => x[1].toUpperCase());
                extractedStyle.animations[key] ??= value;
            }
        }
        else {
            const key = property
                .replace("animation-", "")
                .replace(/-./g, (x) => x[1].toUpperCase());
            extractedStyle.animations ??= {};
            extractedStyle.animations[key] = value;
        }
    }
    function addWarning(warning) {
        const warningRegexArray = options.ignorePropertyWarningRegex;
        if (warningRegexArray) {
            const match = warningRegexArray.some((regex) => new RegExp(regex).test(warning.property));
            if (match)
                return;
        }
        extractedStyle.warnings ??= [];
        extractedStyle.warnings.push(warning);
    }
    function requiresLayout(name) {
        if (name === "rnw") {
            extractedStyle.requiresLayoutWidth = true;
        }
        else {
            extractedStyle.requiresLayoutHeight = true;
        }
    }
    const parseDeclarationOptions = {
        addStyleProp,
        handleStyleShorthand,
        addAnimationProp,
        addContainerProp,
        addTransitionProp,
        requiresLayout,
        addWarning,
        ...options,
    };
    for (const declaration of declarations) {
        (0, parseDeclaration_1.parseDeclaration)(declaration, parseDeclarationOptions);
    }
    return extractedStyle;
}
function kebabToCamelCase(str) {
    if (str.startsWith("-rn-")) {
        str = str.slice("-rn-".length);
    }
    return str.replace(/-./g, (x) => x[1].toUpperCase());
}
function allEqual(...params) {
    return params.every((param, index, array) => {
        return index === 0 ? true : equal(array[0], param);
    });
}
function equal(a, b) {
    if (a === b)
        return true;
    if (typeof a !== typeof b)
        return false;
    if (a === null || b === null)
        return false;
    if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length)
            return false;
        for (let i = 0; i < a.length; i++) {
            if (!equal(a[i], b[i]))
                return false;
        }
        return true;
    }
    if (typeof a === "object" && typeof b === "object") {
        if (Object.keys(a).length !== Object.keys(b).length)
            return false;
        for (const key in a) {
            if (!equal(a[key], b[key]))
                return false;
        }
        return true;
    }
    return false;
}
//# sourceMappingURL=index.js.map